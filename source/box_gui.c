/*
 * This file is part of the PokeBoxDS project.
 * Copyright (C) 2019 Jennifer Berringer
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; even with the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
#include "box_gui.h"
#include <nds.h>
#include <stdio.h>
#include <stdint.h>
#include "util.h"

#include "asset_manager.h"
#include "console_helper.h"
#include "cursor.h"
#include "defWallpapers.h"
#include "boxesTileset.h"
#include "gui_util.h"
#include "message_window.h"
#include "pkmx_format.h"
#include "pokemon_strings.h"
#include "savedata_gen3.h"
#include "string_gen3.h"
#include "sd_boxes.h"
#include "text_draw.h"
#include "utf8.h"

/* Tilemaps generated by build system */
#include "blankWallpaper_map.h"
#include "boxLeftButton_map.h"
#include "boxRightButton_map.h"
#include "pokeStatusPane_map.h"
#include "summaryScreen_map.h"
#include "emptyStatusPane_map.h"
#include "sidePaneButton_map.h"
#include "sidePaneButtonTop_map.h"
#include "sidePaneButtonBottom_map.h"
#include "sidePaneButtonSelect_map.h"

static int activeSprite = 0;

#define GUI_FLAG_SELECTING 0x01
#define GUI_FLAG_HOLDING 0x02
#define GUI_FLAG_HOLDING_MULTIPLE 0x04
#define GUI_FLAG_HOVER_IS_CART 0x08

//static const textLabel_t botLabelGroup = {1, 1, 1, 16};
static const textLabel_t botLabelBox3  = {1, 5, 6, 12};
static const textLabel_t botLabelBox4  = {1, 5, 5, 12};
static const textLabel_t botLabelsInfo[] = {
	{1, 22,  0, 10},
	{1, 22,  2, 10},
	{1, 22, 13, 10},
	{1, 22, 15,  6},
	{1, 28, 15,  2}
};
static const textLabel_t topLabelsSummary[] = {
	{0,  0,  0,  6},
	{0,  7,  0, 10},
	{0, 18,  0,  1},
	{0,  0,  5, 10},
	{0, 11,  5, 11},
	{0,  0,  7, 22},
	{0,  0, 11, 14},
	{0,  0, 13, 14},
	{0,  0, 16, 14},
	{0,  0, 18, 14},
	{0,  0, 20, 14},
	{0,  0, 22, 14},
	{0, 14, 10,  9},
	{0, 25, 10,  7},
	{0, 14, 12,  5},
	{0, 14, 14,  5},
	{0, 14, 16,  5},
	{0, 14, 18,  5},
	{0, 14, 20,  5},
	{0, 14, 22,  5},
	{0, 20, 12, 12},
	{0, 20, 14, 12},
	{0, 20, 16, 12},
	{0, 20, 18, 12},
	{0, 20, 20, 12},
	{0, 20, 22, 12}
};

typedef union box_icon {
	uint16_t value;
	struct {
		uint16_t species : 12;
		uint16_t generation : 4;
	};
} box_icon_t;

struct boxgui_groupView {
	uint8_t groupIdx;
	int8_t activeBox;
	uint8_t numBoxes;
	uint8_t unused_1;
	union {
		uint16_t gameId;
		struct {
			uint8_t generation;
			uint8_t subgen;
		};
	};
	uint16_t unused_2;
	uint16_t pkmSize;
	uint16_t boxSizeBytes;
	uint16_t **boxNames;
	uint8_t *boxWallpapers;
	uint8_t *boxData;
	box_icon_t *boxIcons;
};

struct boxgui_state {
	int8_t cursor_x;
	int8_t cursor_y;
	uint8_t flags;
	uint8_t cursorMode; //TODO
	struct boxgui_groupView topScreen;
	struct boxgui_groupView botScreen;
	int8_t holdingSourceBox;
	uint8_t holdingSourceGroup;
	int8_t holdingSource_x;
	int8_t holdingSource_y;
	int8_t holdingMin_x;
	int8_t holdingMax_x;
	int8_t holdingMin_y;
	int8_t holdingMax_y;
	box_icon_t boxIcons1[32 * 30];
	box_icon_t boxIcons2[32 * 30];
	box_icon_t holdIcons[30];
	uint8_t hoverPkm[PKMX_SIZE];
	uint8_t boxData1[32 * BOX_SIZE_BYTES_X];
	uint8_t boxData2[32 * BOX_SIZE_BYTES_X];
};

static void draw_builtin_wallpaper(const tilemap_t *tilemap, uint8_t screen, uint8_t x, uint8_t y) {
	uint8_t width = tilemap->width;
	uint8_t height = tilemap->height;
	uint16_t *mapRam;
	if (screen) {
		mapRam = BG_MAP_RAM_SUB(BG_MAPBASE_WALLPAPER);
	} else {
		mapRam = BG_MAP_RAM(BG_MAPBASE_WALLPAPER);
	}
	for (int rowIdx = 0; rowIdx < height; rowIdx++) {
		for (int colIdx = 0; colIdx < width; colIdx++) {
			uint16_t tspec = (4 << 12) | tilemap->map[rowIdx * width + colIdx];
			mapRam[(rowIdx + y) * 32 + colIdx + x] = tspec;
		}
	}
}

#include "carts_gen3_24px.h"
#include "carts_gen4_24px.h"
#include "carts_gen5_24px.h"

static void load_cart_sprite(uint8_t *gfx, uint8_t *pal, uint16_t gameId) {
	uint8_t generation, subgen;

	generation = gameId & 0xFF;
	subgen = gameId >> 8;

	if (generation == 3 && subgen < 5) {
		memcpy(gfx, (uint8_t*) carts_gen3_24pxTiles + subgen * 512, 512);
		memcpy(pal, carts_gen3_24pxPal, 32);
	} else if (generation == 4 && subgen < 5) {
		memcpy(gfx, (uint8_t*) carts_gen4_24pxTiles + subgen * 512, 512);
		memcpy(pal, carts_gen4_24pxPal, 32);
	} else if (generation == 5 && subgen < 4) {
		memcpy(gfx, (uint8_t*) carts_gen5_24pxTiles + subgen * 512, 512);
		memcpy(pal, carts_gen5_24pxPal, 32);
	} else {
		memcpy(gfx, (uint8_t*) carts_gen3_24pxTiles + 7 * 512, 512);
		memcpy(pal, carts_gen3_24pxPal, 32);
	}
}

static void update_onescreen_summary(const struct SimplePKM *pkm) {
	const textLabel_t *textLabels = topLabelsSummary;
	uint8_t palette[128];
	static const char *stat_names[] = {"HP", "Atk", "Def", "SpAtk", "SpDef", "Speed"};
	uint16_t genderStr[2] = {0, 0};
	uint8_t genderColor = FONT_BLACK;
	int stat_best = -1;
	int stat_worst = -1;
	const uint8_t *frontSpriteTiles;

	if (!pkm || !pkm->exists) {
		oamMain.oamMemory[OAM_INDEX_CURBOX].attribute[0] = 0;
		oamMain.oamMemory[OAM_INDEX_CURBOX].attribute[1] = 0;
		oamMain.oamMemory[OAM_INDEX_CURBOX].attribute[2] = 0;
		oamMain.oamMemory[OAM_INDEX_BIGSPRITE].attribute[0] = 0;
		oamMain.oamMemory[OAM_INDEX_BIGSPRITE].attribute[1] = 0;
		oamMain.oamMemory[OAM_INDEX_BIGSPRITE].attribute[2] = 0;
		for (int i = 0; i < ARRAY_LENGTH(topLabelsSummary); i++)
			clearText(&topLabelsSummary[i]);
		return;
	}

	if (pkm->gender == 0) {
		genderStr[0] = 0x2642;
		genderColor = FONT_BLUE;
	} else if (pkm->gender == 1) {
		genderStr[0] = 0x2640;
		genderColor = FONT_PINK;
	}

	drawTextFmt(&textLabels[0], FONT_WHITE, FONT_BLACK, "No.%03d", pkm->dexNumber);
	drawText16( &textLabels[1], FONT_WHITE, FONT_BLACK, pkm->nickname);
	drawText16(&textLabels[2], genderColor, FONT_WHITE, genderStr);
	drawText16( &textLabels[3],
		pkm->isOTFemale ? FONT_PINK : FONT_BLUE, FONT_BLACK, pkm->trainerName);
	drawTextFmt(&textLabels[4], FONT_WHITE, FONT_BLACK, "%5d-%05d",
		pkm->trainerId16[0], pkm->trainerId16[1]);
	drawTextFmt(&textLabels[5], FONT_WHITE, FONT_BLACK, "Met: %s", pkm->metLocation);
	drawText(   &textLabels[6], FONT_WHITE, FONT_BLACK, pkm->ability);
	drawText(   &textLabels[7], FONT_WHITE, FONT_BLACK, get_nature_name(pkm->nature));
	for (int i = 0; i < 4; i++) {
		const char *move = get_move_name(pkm->moves[i]);
		if (pkm->moves[i] == 0) {
			clearText(&textLabels[8+i]);
		} else if (move) {
			drawText(&textLabels[8+i], FONT_WHITE, FONT_BLACK, get_move_name(pkm->moves[i]));
		} else {
			drawTextFmt(&textLabels[8+i], FONT_WHITE, FONT_BLACK, "ERROR %d", pkm->moves[i]);
		}
	}
	drawTextFmt(&textLabels[12], FONT_WHITE, FONT_BLACK, "Level %3d", pkm->level);
	drawText(   &textLabels[13], FONT_WHITE, FONT_BLACK, "EV  IV");

	stat_best = pkm->nature / 5 + 1;
	stat_worst = pkm->nature % 5 + 1;
	if (stat_best == stat_worst)
		stat_best = stat_worst = -1;

	for (int i = 0; i < 6; i++) {
		uint8_t color =
			(i == stat_best) ? FONT_RED :
			(i == stat_worst) ? FONT_BLUE : FONT_WHITE;
		drawText(&textLabels[14+i], color, FONT_BLACK, stat_names[i]);
		drawTextFmt(&textLabels[20+i], FONT_WHITE, FONT_BLACK, "%3d %3d  %2d",
			pkm->stats[i], pkm->EVs[i], (int) (pkm->IVs >> (i * 5)) & 31);
	}

	frontSpriteTiles = readFrontImage(palette, pkm->spriteIdx, pkm->isShiny,
		pkm->isOnCart ? 0 : pkm->curGameId);

	memcpy((uint8_t*) SPRITE_PALETTE + 32 * (6 + 0), palette, 32);
	memcpy((uint8_t*) SPRITE_GFX + OBJ_GFXIDX_BIGSPRITE * 128 + 0 * 2048,
		frontSpriteTiles, 2048);
	oamMain.oamMemory[OAM_INDEX_BIGSPRITE].attribute[0] = OBJ_Y(4) | ATTR0_COLOR_16;
	oamMain.oamMemory[OAM_INDEX_BIGSPRITE].attribute[1] = OBJ_X(188) | ATTR1_SIZE_64;
	oamMain.oamMemory[OAM_INDEX_BIGSPRITE].palette = 6 + 0;
	oamMain.oamMemory[OAM_INDEX_BIGSPRITE].gfxIndex = OBJ_GFXIDX_BIGSPRITE + 0 * 16;

	load_cart_sprite(
		(uint8_t*) SPRITE_GFX + OBJ_GFXIDX_CURBOX * 128,
		(uint8_t*) SPRITE_PALETTE + 32 * 9,
		pkm->originGameId);
	oamMain.oamMemory[OAM_INDEX_CURBOX].attribute[0] = OBJ_Y(12) | ATTR0_COLOR_16;
	oamMain.oamMemory[OAM_INDEX_CURBOX].attribute[1] = OBJ_X(0) | ATTR1_SIZE_32;
	oamMain.oamMemory[OAM_INDEX_CURBOX].palette = 9;
	oamMain.oamMemory[OAM_INDEX_CURBOX].gfxIndex = OBJ_GFXIDX_CURBOX;

	/* TODO: Add a row of icons at Y=16
	 * X=00 Cartridge icon for origin game
	 * X=32 Ball
	 * X=64 Held item
	 * X=96 Box icon
	 */
}

static void update_sidepane_summary(const struct SimplePKM *pkm) {
	const textLabel_t *textLabels = botLabelsInfo;
	uint8_t palette[128];
	uint16_t genderStr[2] = {0, 0};
	uint8_t genderColor = FONT_BLACK;
	const uint8_t *frontSpriteTiles;

	if (!pkm || !pkm->exists) {
		draw_gui_tilemap(&emptyStatusPane_map, 1, 21, 0);
		oamSub.oamMemory[OAM_INDEX_BIGSPRITE].attribute[0] = 0;
		oamSub.oamMemory[OAM_INDEX_BIGSPRITE].attribute[1] = 0;
		oamSub.oamMemory[OAM_INDEX_BIGSPRITE].attribute[2] = 0;
		for (int i = 0; i < 5; i++)
			clearText(&textLabels[i]);
		return;
	}

	draw_gui_tilemap(&pokeStatusPane_map, 1, 21, 0);

	if (pkm->gender == 0) {
		genderStr[0] = 0x2642;
		genderColor = FONT_BLUE;
	} else if (pkm->gender == 1) {
		genderStr[0] = 0x2640;
		genderColor = FONT_PINK;
	}

	drawText(   &textLabels[0], FONT_BLACK, FONT_WHITE, get_pokemon_name_by_dex(pkm->dexNumber));
	drawTextFmt(&textLabels[1], FONT_BLACK, FONT_WHITE, "#%03d", pkm->dexNumber);
	drawText16( &textLabels[2], FONT_BLACK, FONT_WHITE, pkm->nickname);
	drawTextFmt(&textLabels[3], FONT_BLACK, FONT_WHITE, "Lv %3d", pkm->level);
	drawText16(&textLabels[4], genderColor, FONT_WHITE, genderStr);

	frontSpriteTiles = readFrontImage(palette, pkm->spriteIdx, pkm->isShiny,
		pkm->isOnCart ? 0 : pkm->curGameId);

	memcpy((uint8_t*) SPRITE_PALETTE_SUB + 32 * (6 + activeSprite), palette, 32);
	memcpy((uint8_t*) SPRITE_GFX_SUB + OBJ_GFXIDX_BIGSPRITE * 128 + activeSprite * 2048,
		frontSpriteTiles, 2048);
	oamSub.oamMemory[OAM_INDEX_BIGSPRITE].attribute[0] = OBJ_Y(36) | ATTR0_COLOR_16;
	oamSub.oamMemory[OAM_INDEX_BIGSPRITE].attribute[1] = OBJ_X(180) | ATTR1_SIZE_64;
	oamSub.oamMemory[OAM_INDEX_BIGSPRITE].palette = 6 + activeSprite;
	oamSub.oamMemory[OAM_INDEX_BIGSPRITE].gfxIndex = OBJ_GFXIDX_BIGSPRITE + activeSprite * 16;
	activeSprite ^= 1;
}

static void status_display_update(const uint8_t *pkmx, int is_cart) {
	struct SimplePKM pkm;

	pkmx_to_simplepkm(&pkm, pkmx, is_cart);
	update_onescreen_summary(&pkm);
	update_sidepane_summary(&pkm);
}

static void load_cursor() {
	oamSub.oamMemory[0].attribute[0] = OBJ_Y(60) | ATTR0_COLOR_16;
	oamSub.oamMemory[0].attribute[1] = OBJ_X(12) | ATTR1_SIZE_32;
	oamSub.oamMemory[0].palette = 8;
	oamSub.oamMemory[0].gfxIndex = 0;
	dmaCopy(cursorTiles, SPRITE_GFX_SUB, sizeof(cursorTiles));
	dmaCopy(cursorPal, SPRITE_PALETTE_SUB + 16 * 8, sizeof(cursorPal));
}

static int display_icon_sprites(
	const box_icon_t *iconList, int oamIndex, int gfxIndex, int x, int y) {

	int obj_idx = 0;

	for (int i = 0; i < 30; i++) {
		box_icon_t icon = iconList[i];
		SpriteEntry *oam = &oamSub.oamMemory[oamIndex + i];

		if (icon.species == 0) {
			oam->attribute[0] = 0;
			oam->attribute[1] = 0;
			oam->attribute[2] = 0;
			continue;
		}

		oam->attribute[0] = OBJ_Y((i / 6) * 24 + y) | ATTR0_COLOR_16;
		oam->attribute[1] = OBJ_X((i % 6) * 24 + x) | ATTR1_SIZE_32;
		oam->palette = getIconPaletteIdx(icon.value);
		oam->gfxIndex = gfxIndex + i * 8;
		// Each 32x32@4bpp sprite is 512 bytes.
		// 2 animation frames at 512 bytes each = 1024 bytes per Pokemon.
		dmaCopy(
			getIconImage(icon.value),
			(uint8_t*) SPRITE_GFX_SUB + gfxIndex * 128 + i * 1024,
			1024);

		obj_idx++;
	}
	return obj_idx;
}

static void move_icon_sprites(int oamIndex, int x, int y) {
	for (int i = 0; i < 30; i++) {
		SpriteEntry *oam = &oamSub.oamMemory[oamIndex + i];

		if (oam->attribute[0] == 0)
			continue;

		oam->attribute[0] = OBJ_Y((i / 6) * 24 + y) | ATTR0_COLOR_16;
		oam->attribute[1] = OBJ_X((i % 6) * 24 + x) | ATTR1_SIZE_32;
	}
}

static void clear_icon_sprites(int oamIndex) {
	for (int i = 0; i < 30; i++) {
		SpriteEntry *oam = &oamSub.oamMemory[oamIndex + i];
		oam->attribute[0] = 0;
		oam->attribute[1] = 0;
		oam->attribute[2] = 0;
	}
}

static void clear_selection_shadow() {
	for (int rowIdx = 9; rowIdx < 24; rowIdx++) {
		for (int colIdx = 0; colIdx < 21; colIdx++) {
			BG_MAP_RAM_SUB(BG_MAPBASE_BUTTONS)[rowIdx * 32 + colIdx] = 0;
		}
	}
}

static void decode_boxes(struct boxgui_groupView *group) {
	uint16_t checksum;
	box_icon_t icon;
	pkm3_t pkm;
	for (int pkmIdx = 0; pkmIdx < 30 * group->numBoxes; pkmIdx++) {
		const uint8_t *bytes;
		int generation;
		bytes = group->boxData + pkmIdx * group->pkmSize;
		generation = group->generation;
		if (generation == 0) {
			generation = bytes[0];
			bytes += 4;
			if (generation == 0) {
				// Blank space
				group->boxIcons[pkmIdx].value = 0;
				continue;
			}
		}
		if (generation != 3) {
			// Question mark for other generations we can't decode yet
			icon.species = 252;
			icon.generation = 3;
			group->boxIcons[pkmIdx] = icon;
			continue;
		}
		checksum = decode_pkm_encrypted_data(&pkm, bytes);
		if (checksum != pkm.checksum)
			icon.species = 412; // Egg icon for Bad EGG
		else
			icon.species = pkm_displayed_species(&pkm);
		icon.generation = group->gameId ? 0 : 3;
		group->boxIcons[pkmIdx] = icon;
	}
}

static void update_cursor(struct boxgui_state *guistate) {
	int cur_poke = guistate->cursor_y * 6 + guistate->cursor_x;
	const struct boxgui_groupView *group;
	int icons_x, icons_y;

	group = &guistate->botScreen;

	if (group->generation == 3) {
		oamSub.oamMemory[0].x = guistate->cursor_x * 24 + 12;
		oamSub.oamMemory[0].y = guistate->cursor_y * 24 + 60;
		icons_x = 12 + guistate->holdingMin_x * 24;
		icons_y = 48 + guistate->holdingMin_y * 24;
	} else {
		oamSub.oamMemory[0].x = guistate->cursor_x * 24 + 8;
		oamSub.oamMemory[0].y = guistate->cursor_y * 24 + 60;
		icons_x = 8 + guistate->holdingMin_x * 24;
		icons_y = 48 + guistate->holdingMin_y * 24;
	}

	if (guistate->flags & GUI_FLAG_HOLDING) {
		move_icon_sprites(OAM_INDEX_HOLDING, icons_x, icons_y);
		status_display_update(guistate->hoverPkm,
			(guistate->flags & GUI_FLAG_HOVER_IS_CART) != 0);
	} else {
		pkm_to_pkmx(guistate->hoverPkm,
			guistate->botScreen.boxData +
			guistate->botScreen.activeBox * guistate->botScreen.boxSizeBytes +
			cur_poke * guistate->botScreen.pkmSize,
			guistate->botScreen.gameId);
		guistate->flags &= ~GUI_FLAG_HOVER_IS_CART;
		if (guistate->botScreen.gameId)
			guistate->flags |= GUI_FLAG_HOVER_IS_CART;
		status_display_update(guistate->hoverPkm,
			(guistate->flags & GUI_FLAG_HOVER_IS_CART) != 0);
	}
	clear_selection_shadow();
	if (guistate->flags & (GUI_FLAG_SELECTING | GUI_FLAG_HOLDING)) {
		uint8_t min_x = (guistate->holdingMin_x    ) * 3 + 2;
		uint8_t max_x = (guistate->holdingMax_x + 1) * 3 + 2;
		uint8_t min_y = (guistate->holdingMin_y    ) * 3 + 9;
		uint8_t max_y = (guistate->holdingMax_y + 1) * 3 + 9;
		for (uint8_t rowIdx = min_y; rowIdx < max_y - 1; rowIdx++) {
			for (uint8_t colIdx = min_x; colIdx < max_x; colIdx++) {
				uint16_t tspec = (8 << 12) | 0x20;
				BG_MAP_RAM_SUB(BG_MAPBASE_BUTTONS)[rowIdx * 32 + colIdx] = tspec;
			}
		}
		if (group->generation != 3) {
			for (uint8_t rowIdx = min_y; rowIdx < max_y - 1; rowIdx++) {
				uint16_t tspec = (8 << 12) | 0x21;
				BG_MAP_RAM_SUB(BG_MAPBASE_BUTTONS)[rowIdx * 32 + min_x - 1] = tspec;
				BG_MAP_RAM_SUB(BG_MAPBASE_BUTTONS)[rowIdx * 32 + max_x - 1] = tspec + 1;
			}
		}
	}
}

static int display_box(const struct boxgui_state *guistate) {
	uint16_t *name;
	int rc;
	const struct boxgui_groupView *group;
	char namebuf[20];
	const textLabel_t *nameLabel;

	group = &guistate->botScreen;
	if (group->boxNames) {
		name = group->boxNames[group->activeBox];
		utf8_encode(namebuf, name, sizeof(namebuf));
	} else {
		sprintf(namebuf, "BOX %d", group->activeBox + 1);
		name = NULL;
	}
	rc = 0;
	if (group->boxWallpapers) {
		int wallpaper;
		wallpaper = group->boxWallpapers[group->activeBox];
		rc = loadWallpaper(wallpaper);
	}

	selectBottomConsole();
	if (group->generation == 3) {
		nameLabel = &botLabelBox3;
		clearText(&botLabelBox4);
	} else {
		nameLabel = &botLabelBox4;
		clearText(&botLabelBox3);
	}
	drawText(nameLabel, FONT_BLACK, FONT_WHITE, namebuf);

	bgInit(BG_LAYER_BUTTONS, BgType_Text4bpp, BgSize_T_256x256,
		BG_MAPBASE_BUTTONS, BG_TILEBASE_BUTTONS);
	bgInit(BG_LAYER_WALLPAPER, BgType_Text4bpp, BgSize_T_256x256,
		BG_MAPBASE_WALLPAPER, BG_TILEBASE_WALLPAPER);
	bgInitSub(BG_LAYER_BUTTONS, BgType_Text4bpp, BgSize_T_256x256,
		BG_MAPBASE_BUTTONS, BG_TILEBASE_BUTTONS);
	bgInitSub(BG_LAYER_WALLPAPER, BgType_Text4bpp, BgSize_T_256x256,
		BG_MAPBASE_WALLPAPER, BG_TILEBASE_WALLPAPER);

	memset(BG_MAP_RAM_SUB(BG_MAPBASE_BUTTONS), 0, 2048);
	memset(BG_MAP_RAM_SUB(BG_MAPBASE_WALLPAPER), 0, 2048);

	memcpy(BG_TILE_RAM(BG_TILEBASE_BUTTONS), boxesTilesetTiles, sizeof(boxesTilesetTiles));
	memcpy((uint8_t*) BG_PALETTE + 32 * 8, boxesTilesetPal, sizeof(boxesTilesetPal));
	memcpy(BG_TILE_RAM_SUB(BG_TILEBASE_BUTTONS), boxesTilesetTiles, sizeof(boxesTilesetTiles));
	memcpy((uint8_t*) BG_PALETTE_SUB + 32 * 8, boxesTilesetPal, sizeof(boxesTilesetPal));

	draw_gui_tilemap(&summaryScreen_map, 0, 0, 0);
	draw_gui_tilemap(&emptyStatusPane_map, 1, 21, 0);
	if (group->generation == 3) {
		draw_gui_tilemap(&boxLeftButton_map, 1, 1, 6);
		draw_gui_tilemap(&boxRightButton_map, 1, 19, 6);
	} else {
		draw_gui_tilemap(&boxLeftButton_map, 1, 1, 5);
		draw_gui_tilemap(&boxRightButton_map, 1, 18, 5);
	}

	if (rc) {
		int wallpaperPalOffset = 4;
		memcpy(BG_TILE_RAM_SUB(BG_TILEBASE_WALLPAPER), wallpaperTiles, sizeof(wallpaperTiles));
		memcpy((uint8_t*) BG_PALETTE_SUB + 32 * wallpaperPalOffset,
			wallpaperPal, sizeof(wallpaperPal));
		for (int rowIdx = 0; rowIdx < 18; rowIdx++) {
			for (int colIdx = 0; colIdx < 20; colIdx++) {
				uint16_t tspec = wallpaperTilemap[rowIdx * 20 + colIdx];
				uint8_t pal = tspec >> 12;
				if (pal)
					pal += wallpaperPalOffset - 1;
				tspec = (pal << 12) | (tspec & 0xFFF);
				BG_MAP_RAM_SUB(BG_MAPBASE_WALLPAPER)[(rowIdx + 6) * 32 + colIdx + 1] = tspec;
			}
		}
	} else {
		memcpy(BG_TILE_RAM_SUB(BG_TILEBASE_WALLPAPER), defWallpapersTiles,
			sizeof(defWallpapersTiles));
		memcpy((uint8_t*) BG_PALETTE_SUB + 32 * 4, defWallpapersPal, sizeof(defWallpapersPal));
		draw_builtin_wallpaper(&blankWallpaper_map, 1, 0, 5);
	}

	int icons_x, icons_y;
	if (group->generation == 3) {
		icons_x = 12;
		icons_y = 60;
	} else {
		icons_x = 8;
		icons_y = 60;
	}

	rc = display_icon_sprites(
		group->boxIcons + group->activeBox * 30,
		OAM_INDEX_CURBOX, OBJ_GFXIDX_CURBOX,
		icons_x, icons_y);
	return rc;
}

static int switch_box(struct boxgui_state *guistate, int rel) {
	struct boxgui_groupView *group;
	int activeBox;

	group = &guistate->botScreen;
	activeBox = group->activeBox + rel;

	if (activeBox < 0)
		activeBox = group->numBoxes - 1;
	else if (activeBox >= group->numBoxes)
		activeBox = 0;
	group->activeBox = activeBox;
	display_box(guistate);
	update_cursor(guistate);
	return 1;
}

static void swap_screens(struct boxgui_state *guistate) {
	struct boxgui_groupView tmpGroup;
	tmpGroup = guistate->topScreen;
	guistate->topScreen = guistate->botScreen;
	guistate->botScreen = tmpGroup;
	display_box(guistate);
	update_cursor(guistate);
}

static void move_cursor_x(struct boxgui_state *guistate, int rel) {
	int8_t cursor_x = guistate->cursor_x + rel;
	int8_t min_x = guistate->holdingMin_x;
	int8_t max_x = guistate->holdingMax_x;

	if (guistate->flags & GUI_FLAG_HOLDING_MULTIPLE) {
		min_x += rel;
		max_x += rel;

		// Switch boxes when passing the left/right edges of a box
		if (min_x < 0) {
			switch_box(guistate, -1);
			cursor_x += 5 - max_x;
			min_x += 5 - max_x;
			max_x = 5;
		}
		else if (max_x > 5) {
			switch_box(guistate, 1);
			cursor_x -= min_x;
			max_x -= min_x;
			min_x = 0;
		}
	} else if (guistate->flags & GUI_FLAG_SELECTING) {
		// Stop when trying to pass the left/right edges of a box
		if (cursor_x < 0 || cursor_x > 5)
			return;
		if (min_x > cursor_x)
			min_x = cursor_x;
		else if (max_x < cursor_x)
			max_x = cursor_x;
		else if (rel > 0)
			min_x = cursor_x;
		else if (rel < 0)
			max_x = cursor_x;
	} else {
		// Wraparound when passing the left/right edges of a box
		if (cursor_x < 0)
			cursor_x = 5;
		else if (cursor_x > 5)
			cursor_x = 0;
		max_x = min_x = cursor_x;
	}

	guistate->cursor_x = cursor_x;
	guistate->holdingMin_x = min_x;
	guistate->holdingMax_x = max_x;
	update_cursor(guistate);
}

static void move_cursor_y(struct boxgui_state *guistate, int rel) {
	int8_t cursor_y = guistate->cursor_y + rel;
	int8_t min_y = guistate->holdingMin_y;
	int8_t max_y = guistate->holdingMax_y;

	if (guistate->flags & GUI_FLAG_HOLDING_MULTIPLE) {
		min_y += rel;
		max_y += rel;
		// Stop when trying to pass the top/bottom edges of a box
		if (min_y < 0 || max_y > 4)
			return;
	} else if (guistate->flags & GUI_FLAG_SELECTING) {
		// Stop when trying to pass the top/bottom edges of a box
		if (cursor_y < 0 || cursor_y > 4)
			return;
		if (min_y > cursor_y)
			min_y = cursor_y;
		else if (max_y < cursor_y)
			max_y = cursor_y;
		else if (rel > 0)
			min_y = cursor_y;
		else if (rel < 0)
			max_y = cursor_y;
	} else {
		// Wraparound when passing the top/bottom edges of a box
		if (cursor_y < 0)
			cursor_y = 4;
		else if (cursor_y > 4)
			cursor_y = 0;
		max_y = min_y = cursor_y;
	}

	guistate->cursor_y = cursor_y;
	guistate->holdingMin_y = min_y;
	guistate->holdingMax_y = max_y;
	update_cursor(guistate);
}

static void start_selection(struct boxgui_state *guistate) {
	guistate->holdingMin_x = guistate->cursor_x;
	guistate->holdingMax_x = guistate->cursor_x;
	guistate->holdingMin_y = guistate->cursor_y;
	guistate->holdingMax_y = guistate->cursor_y;
	guistate->flags = GUI_FLAG_SELECTING;
	update_cursor(guistate);
}

static void pickup_selection(struct boxgui_state *guistate) {
	uint8_t flags = GUI_FLAG_HOLDING;
	int width  = guistate->holdingMax_x - guistate->holdingMin_x + 1;
	int height = guistate->holdingMax_y - guistate->holdingMin_y + 1;
	int dx = guistate->holdingMin_x;
	int dy = guistate->holdingMin_y;
	int icons_x, icons_y;
	struct boxgui_groupView *group = &guistate->botScreen;
	box_icon_t *curBoxIcons = group->boxIcons + 30 * group->activeBox;
	int isPopulated = 0;

	if (width * height > 1)
		flags |= GUI_FLAG_HOLDING_MULTIPLE;
	flags |= guistate->flags &
		~(GUI_FLAG_SELECTING | GUI_FLAG_HOLDING | GUI_FLAG_HOLDING_MULTIPLE);
	guistate->flags = flags;
	guistate->holdingSourceBox = group->activeBox;
	guistate->holdingSourceGroup = group->groupIdx;
	guistate->holdingSource_x = guistate->holdingMin_x;
	guistate->holdingSource_y = guistate->holdingMin_y;
	for (int y = 0; y < height; y++) {
		for (int x = 0; x < width; x++) {
			box_icon_t tmp;
			tmp = guistate->holdIcons[y * 6 + x] = curBoxIcons[(y + dy) * 6 + (x + dx)];
			curBoxIcons[(y + dy) * 6 + (x + dx)].species = 0;
			if (tmp.species)
				isPopulated = 1;
		}
	}

	// Lose the selection if nothing is actually there
	if (!isPopulated)
		guistate->flags = 0;

	if (group->generation == 3) {
		icons_x = 12 + 24 * dx;
		icons_y = 48 + 24 * dy;
	} else {
		icons_x = 8 + 24 * dx;
		icons_y = 48 + 24 * dy;
	}

	display_icon_sprites(
		guistate->holdIcons, OAM_INDEX_HOLDING, OBJ_GFXIDX_HOLDING,
		icons_x, icons_y);
	display_box(guistate);
	update_cursor(guistate);
}

// Drop the held Pokemon back where they came from
static void drop_holding(struct boxgui_state *guistate) {
	int width  = guistate->holdingMax_x - guistate->holdingMin_x + 1;
	int height = guistate->holdingMax_y - guistate->holdingMin_y + 1;
	int sx = guistate->holdingSource_x;
	int sy = guistate->holdingSource_y;
	struct boxgui_groupView *group = &guistate->botScreen;
	struct boxgui_groupView *srcGroup = group;
	box_icon_t *srcBoxIcons;

	if (group->groupIdx != guistate->holdingSourceGroup)
		srcGroup = &guistate->topScreen;
	srcBoxIcons = srcGroup->boxIcons + 30 * guistate->holdingSourceBox;

	for (int y = 0; y < height; y++) {
		for (int x = 0; x < width; x++) {
			srcBoxIcons[(y + sy) * 6 + (x + sx)] = guistate->holdIcons[y * 6 + x];
			guistate->holdIcons[y * 6 + x].value = 0;
		}
	}

	guistate->cursor_x += guistate->holdingSource_x - guistate->holdingMin_x;
	guistate->cursor_y += guistate->holdingSource_y - guistate->holdingMin_y;
	srcGroup->activeBox = guistate->holdingSourceBox;
	guistate->flags = 0;
	clear_icon_sprites(OAM_INDEX_HOLDING);

	display_box(guistate);
	update_cursor(guistate);
}

static void store_holding(struct boxgui_state *guistate) {
	int width  = guistate->holdingMax_x - guistate->holdingMin_x + 1;
	int height = guistate->holdingMax_y - guistate->holdingMin_y + 1;
	int dx = guistate->holdingMin_x;
	int dy = guistate->holdingMin_y;
	int sx = guistate->holdingSource_x;
	int sy = guistate->holdingSource_y;
	int x_start, x_iter, x_end, y_start, y_iter, y_end;
	struct boxgui_groupView *srcGroup, *dstGroup;
	box_icon_t *dstBoxIcons, *srcBoxIcons;
	uint8_t *dstBoxData, *srcBoxData;

	dstGroup = &guistate->botScreen;
	if (guistate->holdingSourceGroup == guistate->botScreen.groupIdx) {
		srcGroup = &guistate->botScreen;
	} else {
		srcGroup = &guistate->topScreen;
	}
	dstBoxIcons = dstGroup->boxIcons + dstGroup->activeBox * 30;
	srcBoxIcons = srcGroup->boxIcons + guistate->holdingSourceBox * 30;
	dstBoxData = dstGroup->boxData + dstGroup->activeBox * dstGroup->boxSizeBytes;
	srcBoxData = srcGroup->boxData + guistate->holdingSourceBox * srcGroup->boxSizeBytes;

	if (guistate->flags & GUI_FLAG_HOLDING_MULTIPLE) {
		// Do nothing if any spot in the destination is occupied.
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				if (dstBoxIcons[(y + dy) * 6 + (x + dx)].species && guistate->holdIcons[y * 6 + x].species)
					return;
			}
		}
	}

	/* Reverse the iteration order depending on the source/dest relative positions.
	 * When the source/dest regions are in the same box and overlapping, this avoids potential
	 * problems with overwriting source data before using it. There's no need to check whether
	 * the regions actually overlap because the iteration order doesn't matter otherwise.
	 */
	x_start = y_start = 0;
	x_iter = y_iter = 1;
	x_end = width;
	y_end = height;
	if (dx > sx) {
		x_start = x_end - 1;
		x_end = -1;
		x_iter = -1;
	}
	if (dy > sy) {
		y_start = y_end - 1;
		y_end = -1;
		y_iter = -1;
	}

	// Swap the contents of holdingSource and the destination
	for (int y = y_start; y != y_end; y += y_iter) {
		for (int x = x_start; x != x_end; x += x_iter) {
			uint8_t *srcPkm;
			uint8_t *dstPkm;
			uint8_t tmpPkm1[PKMX_SIZE];
			uint8_t tmpPkm2[PKMX_SIZE];
			int srcIdx, dstIdx;

			if (guistate->holdIcons[y * 6 + x].species == 0)
				continue;

			srcIdx = (y + sy) * 6 + (x + sx);
			dstIdx = (y + dy) * 6 + (x + dx);

			srcPkm = srcBoxData + srcIdx * srcGroup->pkmSize;
			dstPkm = dstBoxData + dstIdx * dstGroup->pkmSize;

			srcBoxIcons[srcIdx] = dstBoxIcons[dstIdx];
			dstBoxIcons[dstIdx] = guistate->holdIcons[y * 6 + x];
			if (srcBoxIcons[srcIdx].species) {
				srcBoxIcons[srcIdx].generation = srcGroup->gameId ? 0 : 3;
			}
			dstBoxIcons[dstIdx].generation = dstGroup->gameId ? 0 : 3;

			pkm_to_pkmx(tmpPkm1, srcPkm, srcGroup->gameId);
			pkm_to_pkmx(tmpPkm2, dstPkm, dstGroup->gameId);

			// If unable to put a Pokemon down, keep it in holding
			if (!pkmx_convert_generation(tmpPkm1, dstGroup->generation))
				continue;
			if (!pkmx_convert_generation(tmpPkm2, srcGroup->generation))
				continue;

			// TODO Save any lost-in-conversion data when depositing to a game
			// ...after implementing any actual generation conversions
			pkmx_to_pkm(dstPkm, tmpPkm1, dstGroup->generation);
			pkmx_to_pkm(srcPkm, tmpPkm2, srcGroup->generation);

			// Clear this Pokemon from the holding list
			guistate->holdIcons[y * 6 + x].value = 0;
			SpriteEntry *oam = &oamSub.oamMemory[OAM_INDEX_HOLDING + y * 6 + x];
			oam->attribute[0] = 0;
			oam->attribute[1] = 0;
			oam->attribute[2] = 0;
		}
	}

	int isStillHolding = 0;
	for (int i = 0; i < 30; i++) {
		if (guistate->holdIcons[i].species) {
			isStillHolding = 1;
			break;
		}
	}

	if (!isStillHolding)
		guistate->flags = 0;

	display_box(guistate);
	update_cursor(guistate);
}

int open_context_menu(struct boxgui_state *guistate, const char *const *opts, int optc) {
	int out = -1;
	int selected = 0;
	uint8_t start_y = 24 - 3 * optc;

	// Clear the Pokemon mini-summary because it occupies the same screen space
	oamSub.oamMemory[OAM_INDEX_BIGSPRITE].attribute[0] = 0;
	oamSub.oamMemory[OAM_INDEX_BIGSPRITE].attribute[1] = 0;
	oamSub.oamMemory[OAM_INDEX_BIGSPRITE].attribute[2] = 0;
	oamUpdate(&oamSub);
	for (int i = 0; i < ARRAY_LENGTH(botLabelsInfo); i++)
		clearText(&botLabelsInfo[i]);
	draw_gui_tilemap(&emptyStatusPane_map, 1, 21, 0);

	for (int i = 0; i < optc; i++) {
		textLabel_t label = {1, 22, start_y + i * 3, 9};

		draw_gui_tilemap(&sidePaneButton_map, 1, 21, start_y + i * 3);
		drawText(&label, FONT_WHITE, FONT_BLACK, opts[i]);
	}
	draw_gui_tilemap(&sidePaneButtonSelect_map, 1, 21, start_y);
	draw_gui_tilemap(&sidePaneButtonTop_map, 1, 21, start_y - 1);
	draw_gui_tilemap(&sidePaneButtonBottom_map, 1, 21, 23);

	for (;;) {
		KEYPAD_BITS keys;
		swiWaitForVBlank();

		scanKeys();
		keys = keysDown();
		if (keys & KEY_A) {
			out = selected;
			break;
		} else if (keys & KEY_B) {
			out = -1;
			break;
		} else if (keys & KEY_DOWN) {
			draw_gui_tilemap(&sidePaneButton_map, 1, 21, start_y + 3 * selected);
			selected++;
			if (selected >= optc) selected = 0;
			draw_gui_tilemap(&sidePaneButtonSelect_map, 1, 21, start_y + 3 * selected);
		} else if (keys & KEY_UP) {
			draw_gui_tilemap(&sidePaneButton_map, 1, 21, start_y + 3 * selected);
			selected--;
			if (selected < 0) selected = optc - 1;
			draw_gui_tilemap(&sidePaneButtonSelect_map, 1, 21, start_y + 3 * selected);
		}
	}

	for (int i = 0; i < optc; i++) {
		textLabel_t label = {1, 22, start_y + i * 3, 9};
		clearText(&label);
	}

	draw_gui_tilemap(&emptyStatusPane_map, 1, 21, 0);

	return out;
}

static int save_boxes(struct boxgui_state *guistate) {
	write_boxes_savedata(guistate->boxData1);
	if (!sd_boxes_save(guistate->boxData2, 0, 32))
		return 0;
	if (!write_savedata())
		return 0;
	return 1;
}

void open_boxes_gui() {
	struct boxgui_state *guistate;
	const int NUM_BOXES = 14;
	uint16_t box_name_buffer[9 * NUM_BOXES];
	uint16_t *box_names[NUM_BOXES];

	sysSetBusOwners(true, true);
	swiDelay(10);

	initConsoles();
	clearConsoles();
	set_message_screen(0);

	// Load box names
	{
		const uint8_t *box_name;
		box_name = GET_SAVEDATA_SECTION(13) + 0x744;
		// Box names can be up to 8 characters and always include a 0xFF terminator for 9 bytes
		for (int i = 0; i < NUM_BOXES; i++, box_name += 9) {
			uint16_t *out;
			out = box_names[i] = box_name_buffer + 9 * i;
			decode_gen3_string16(out, box_name, 9, activeGameLanguage);
		}
	}

	// Initial GUI state
	guistate = calloc(1, sizeof(struct boxgui_state));
	guistate->botScreen.boxNames = box_names;
	guistate->botScreen.boxWallpapers = GET_SAVEDATA_SECTION(13) + 0x7C2;
	guistate->botScreen.groupIdx = 0x40;
	guistate->botScreen.gameId = activeGameGen | ((uint16_t) activeGameSubGen << 8);
	guistate->botScreen.numBoxes = 14;
	guistate->botScreen.pkmSize = PKM3_SIZE;
	guistate->botScreen.boxSizeBytes = PKM3_SIZE * 30;
	guistate->botScreen.activeBox = load_boxes_savedata(guistate->boxData1);
	guistate->botScreen.boxData = guistate->boxData1;
	guistate->botScreen.boxIcons = guistate->boxIcons1;
	guistate->topScreen.groupIdx = 0;
	guistate->topScreen.gameId = 0;
	guistate->topScreen.numBoxes = 32;
	guistate->topScreen.boxData = guistate->boxData2;
	guistate->topScreen.boxIcons = guistate->boxIcons2;
	guistate->topScreen.pkmSize = PKMX_SIZE;
	guistate->topScreen.boxSizeBytes = PKMX_SIZE * 30;

	if (!sd_boxes_load(guistate->topScreen.boxData, 0, &guistate->topScreen.numBoxes)) {
		open_message_window("Error loading from SD card");
		free(guistate);
		return;
	}

	oamInit(&oamMain, SpriteMapping_1D_128, false);
	oamInit(&oamSub, SpriteMapping_1D_128, false);

	// Load all Pokemon box icon palettes into VRAM
	dmaCopy(getIconPaletteColors(0), (uint8_t*) SPRITE_PALETTE, 32 * 6);
	dmaCopy(getIconPaletteColors(0), (uint8_t*) SPRITE_PALETTE_SUB, 32 * 6);

	// Initial display
	load_cursor();
	resetTextLabels(0);
	resetTextLabels(1);
	decode_boxes(&guistate->botScreen);
	decode_boxes(&guistate->topScreen);
	display_box(guistate);
	update_cursor(guistate);
	oamUpdate(&oamMain);
	oamUpdate(&oamSub);
	keysSetRepeat(20, 10);

	for (;;) {
		KEYPAD_BITS keys;
		swiWaitForVBlank();

		scanKeys();
		keys = keysDown();
		if (keys & KEY_A) {
			if (guistate->flags & GUI_FLAG_HOLDING) {
				store_holding(guistate);
			} else if ((guistate->flags & GUI_FLAG_SELECTING) == 0) {
				start_selection(guistate);
			}
		} else if (keys & KEY_B) {
			if (guistate->flags & GUI_FLAG_HOLDING) {
				drop_holding(guistate);
			} else {
				const char *opts[] = {"Save+Quit", "Quit", "Back"};
				int selected = -1;
				selected = open_context_menu(guistate, opts, ARRAY_LENGTH(opts));
				if (selected == 0) {
					if (save_boxes(guistate))
						break;
					display_box(guistate);
					update_cursor(guistate);
				} else if (selected == 1) {
					break;
				} else {
					update_cursor(guistate);
				}
			}
		} else if (keys & KEY_X) {
			if ((guistate->flags & GUI_FLAG_SELECTING) == 0) {
				swap_screens(guistate);
			}
		}
		if ((keysHeld() & KEY_A) == 0 && (guistate->flags & GUI_FLAG_SELECTING)) {
			pickup_selection(guistate);
		}
		keys = (KEYPAD_BITS) keysDownRepeat();
		if (keys & (KEY_LEFT | KEY_RIGHT)) {
			move_cursor_x(guistate, (keys & KEY_LEFT) ? -1 : 1);
		} else if (keys & (KEY_UP | KEY_DOWN)) {
			move_cursor_y(guistate, (keys & KEY_UP) ? -1 : 1);
		} else if (keys & (KEY_L | KEY_R)) {
			if ((guistate->flags & GUI_FLAG_SELECTING) == 0)
				switch_box(guistate, (keys & KEY_L) ? -1 : 1);
		}
		oamUpdate(&oamMain);
		oamUpdate(&oamSub);
	}

	videoBgDisable(BG_LAYER_BUTTONS);
	videoBgDisable(BG_LAYER_WALLPAPER);
	videoBgDisableSub(BG_LAYER_BUTTONS);
	videoBgDisableSub(BG_LAYER_WALLPAPER);
	oamDisable(&oamMain);
	oamDisable(&oamSub);
	clearConsoles();
	selectTopConsole();
	free(guistate);
	clearConsoles();
}

/*
 * Valid color values for GBA/DS 5-bits-per-channel:
	00 08 10 18 20 29 31 39 41 4a 52 5a 62 6a 73 7b
	83 8b 94 9c a4 ac b4 bd c5 cd d5 de e6 ee f6 ff
*/

